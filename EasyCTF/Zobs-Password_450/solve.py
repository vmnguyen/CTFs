import fractions

e = 9

N1 = 48745513909415950249193852490748282658783771842894506915970265617781072136127
tot1 = 48745513909415950249193852490748282658341764795034225998421553287331062423600
c1 = 17201725667105191004850858218213017224329062968766430861055649017033299195718

N2 = 1327743158253053272799892552065139261714437931794489490096896912706792265519796107
tot2 = 1327743158253053272799892552065139261714364012657978847469237608797691095495117096
c2 = 580643608808827846774435023130429233296642945167202885053223892615502167427750216

N3 = 1539293215516543361803309404983157195962166679388643913224981530179765687571182429
c3 = 612102134077285189313159861903366413107283975401640292720698781770112140524150362

N4 = 1486495521323197278721467478947264978640370056509460663290697571766964507143129889
c4 = 872772972097180903931040426920323096549975628998302528258530464825324890793786279

N5 = 33372653348686024789398348605410304375781657360958849651103906541192079142923284153660138869243991577421232531618241
c5 = 3467937286394430337734938720139690895215022758650818645355937925495036790148158669463044245775149887208883228542940

def egcd(a,b): # Extended Euclidean Algorithm
    if a == 0:
        return (b,0,1);
    else:
        g,y,x = egcd(b%a,a);
        return (g, x - (b // a) * y, y);

def modinv(a,m): # Modular Inverse Finder
    g, x, y = egcd(a,m);
    if g != 1:
        raise Exception('modular inverse does not exist');
    else:
        return x % m;

d1 = modinv(e,tot1)
print hex(pow(c1,d1,N1))[2:-1].decode("hex")
# d2 = modinv(e,tot2)
# print hex(pow(c2,d2,N2))[2:-1].decode("hex")

#flag{sH0r+_m3554g3}
